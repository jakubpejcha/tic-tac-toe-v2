{"ast":null,"code":"var _jsxFileName = \"/home/jakub/Projects/tic-tac-toe/client/src/Board.tsx\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport Cell from './Cell';\nimport { checkWinner } from './checkWinner';\nimport { findBestMove } from './minimax';\nimport Modal from './Modal';\nimport './styles/Board.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst getDimensions = numRows => {\n  const dimensions = {\n    BOARD_NUM_ROWS: numRows,\n    SIZE: '',\n    DELAY: 0,\n    WIN_STREAK: 0\n  };\n  if (numRows === 3) dimensions.SIZE = '--small';\n  if (numRows === 10) dimensions.SIZE = '--large';\n  if (numRows === 3) dimensions.DELAY = 150;\n  if (numRows === 10) dimensions.DELAY = 10;\n  dimensions.WIN_STREAK = numRows >= 5 ? 5 : numRows;\n  return dimensions;\n};\n\nconst Board = ({\n  scoreHandler,\n  restart,\n  handleRestart,\n  size,\n  isAI\n}) => {\n  _s();\n\n  const dimensions = getDimensions(size);\n  const [isWinner, setIsWinner] = useState(false);\n  const [isDraw, setIsDraw] = useState(false);\n  const [numMoves, setNumMoves] = useState(0);\n  const [player, setPlayer] = useState('x');\n  const [cells, setCells] = useState(Array(dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS).fill({\n    showClassName: '',\n    takenByPlayer: '',\n    winning: false\n  }));\n  const [lastCell, setLastCell] = useState(-1); // restart board\n\n  useEffect(() => {\n    if (!restart) return;\n    setIsWinner(false);\n    setIsDraw(false);\n    setNumMoves(0);\n    setPlayer('x');\n    cells.forEach((cell, index) => {\n      setCells(prevCells => {\n        const newCells = [...prevCells];\n        newCells[index] = { ...cell,\n          takenByPlayer: '',\n          winning: false\n        };\n        return newCells;\n      });\n    });\n    setLastCell(-1);\n    handleRestart(false);\n  }, [restart]); // Nice animation of creating the board\n\n  const showBoard = () => {\n    cells.forEach((cell, index) => {\n      setTimeout(() => {\n        setCells(prevCells => {\n          const newCells = [...prevCells];\n          newCells[index] = { ...cell,\n            showClassName: ' show'\n          };\n          return newCells;\n        });\n      }, index * dimensions.DELAY);\n    });\n  };\n\n  useEffect(() => {\n    showBoard();\n  }, []);\n\n  const onCellClick = index => {\n    setCells(prevCells => {\n      // in case cell has been clicked before\n      if (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n      const newCells = [...prevCells];\n      newCells[index] = { ...prevCells[index],\n        takenByPlayer: ` ${player}`\n      };\n      setNumMoves(prevNum => prevNum + 1);\n      setLastCell(index);\n      return newCells;\n    });\n  };\n\n  useEffect(() => {\n    //TEST\n    if (lastCell === -1) return; // do not run after app starts\n\n    const result = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\n    if (result && Array.isArray(result)) {\n      setIsWinner(true);\n      scoreHandler(player);\n      setCells(prevCells => {\n        const newCells = [...prevCells];\n        result.forEach(cell => {\n          newCells[cell] = { ...prevCells[cell],\n            winning: true\n          };\n        });\n        return newCells;\n      });\n      return;\n    } //console.log(checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK));\n    // check for draw\n\n\n    if (numMoves === dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS) {\n      setIsDraw(true);\n      return;\n    }\n\n    ;\n    setPlayer(prevPlayer => {\n      if (prevPlayer === 'x') return 'o';\n      return 'x';\n    });\n  }, [lastCell]); //AI move\n\n  useEffect(() => {\n    if (player === 'o' && isAI) {\n      setCells(prevCells => {\n        // in case cell has been clicked before\n        // forAI\n        const boardData = {\n          cells: prevCells,\n          currentPlayer: 'o',\n          size: dimensions.BOARD_NUM_ROWS,\n          lastCellIndex: lastCell,\n          winStreak: dimensions.WIN_STREAK\n        };\n        const index = findBestMove(boardData);\n        const newCells = [...prevCells];\n        newCells[index] = { ...prevCells[index],\n          takenByPlayer: ' o'\n        };\n        setNumMoves(prevNum => prevNum + 1);\n        setLastCell(index);\n        return newCells;\n      });\n    }\n  }, [player]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: `board board_${dimensions.BOARD_NUM_ROWS}`,\n      children: cells.map((cell, pos) => /*#__PURE__*/_jsxDEV(Cell, {\n        index: pos,\n        showClassName: cell.showClassName,\n        takenByPlayer: cell.takenByPlayer,\n        winning: cell.winning,\n        currentPlayer: ` current_${player}`,\n        size: dimensions.SIZE,\n        onClickCallback: onCellClick\n      }, pos, false, {\n        fileName: _jsxFileName,\n        lineNumber: 210,\n        columnNumber: 6\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 4\n    }, this), /*#__PURE__*/_jsxDEV(Modal, {\n      isWinner: isWinner,\n      isDraw: isDraw,\n      winner: player\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 4\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Board, \"XQpXcE2Qv7mVWoWqMhPN2qTyiVU=\");\n\n_c = Board;\nexport default Board;\n\nvar _c;\n\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/client/src/Board.tsx"],"names":["useState","useEffect","Cell","checkWinner","findBestMove","Modal","getDimensions","numRows","dimensions","BOARD_NUM_ROWS","SIZE","DELAY","WIN_STREAK","Board","scoreHandler","restart","handleRestart","size","isAI","isWinner","setIsWinner","isDraw","setIsDraw","numMoves","setNumMoves","player","setPlayer","cells","setCells","Array","fill","showClassName","takenByPlayer","winning","lastCell","setLastCell","forEach","cell","index","prevCells","newCells","showBoard","setTimeout","onCellClick","prevNum","result","isArray","prevPlayer","boardData","currentPlayer","lastCellIndex","winStreak","map","pos"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\nimport Cell from './Cell';\nimport { CellInterface } from './shared/interfaces';\nimport { checkWinner } from './checkWinner';\nimport { findBestMove } from './minimax';\nimport Modal from './Modal';\nimport './styles/Board.css';\n\ninterface Dimensions {\n\tBOARD_NUM_ROWS: number,\n\tSIZE: string,\n\tDELAY: number,\n\tWIN_STREAK: number\n}\n\nconst getDimensions = (numRows: number): Dimensions => {\n\tconst dimensions = {\n\t\tBOARD_NUM_ROWS: numRows,\n\t\tSIZE: '',\n\t\tDELAY: 0,\n\t\tWIN_STREAK: 0\n\t}\n\n\tif (numRows === 3) dimensions.SIZE = '--small';\n\tif (numRows === 10) dimensions.SIZE = '--large';\n\n\tif (numRows === 3) dimensions.DELAY = 150;\n\tif (numRows === 10) dimensions.DELAY = 10;\n\n\tdimensions.WIN_STREAK = numRows >= 5 ? 5 : numRows;\n\n\treturn dimensions;\n}\n\ninterface Props {\n\tscoreHandler: (updatePlayer: string) => void,\n\trestart: boolean,\n\thandleRestart: (restart: boolean) => void,\n\tsize: number,\n\tisAI:boolean\n}\n\nconst Board = ({ scoreHandler, restart, handleRestart, size, isAI }: Props) => {\n\n\tconst dimensions = getDimensions(size);\n\n\tconst [isWinner, setIsWinner] = useState(false);\n\n\tconst [isDraw, setIsDraw] = useState(false);\n\n\tconst [numMoves, setNumMoves] = useState(0);\n\n\tconst [player, setPlayer] = useState('x');\n\n\tconst [cells, setCells] = useState<CellInterface[]>(Array(dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS).fill({\n\t\tshowClassName: '',\n\t\ttakenByPlayer: '',\n\t\twinning: false,\n\t}));\n\n\tconst [lastCell, setLastCell] = useState(-1);\n\n\t// restart board\n\tuseEffect(() => {\n\t\t\n\t\tif (!restart) return;\n\n\t\tsetIsWinner(false);\n\t\tsetIsDraw(false);\n\t\tsetNumMoves(0);\n\t\tsetPlayer('x');\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetCells(prevCells => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\tnewCells[index] = {\n\t\t\t\t\t...cell,\n\t\t\t\t\ttakenByPlayer: '',\n\t\t\t\t\twinning: false\n\t\t\t\t}\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t});\n\t\t\n\t\tsetLastCell(-1);\n\n\t\thandleRestart(false);\n\t\t\n\t}, [restart]);\n\n\t// Nice animation of creating the board\n\tconst showBoard = () => {\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetCells((prevCells) => {\n\t\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\t\tnewCells[index] = {\n\t\t\t\t\t\t...cell,\n\t\t\t\t\t\tshowClassName: ' show'\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn newCells;\n\t\t\t\t});\n\t\t\t}, index * dimensions.DELAY);\n\t\t});\n\t};\n\n\tuseEffect(() => {\n\t\tshowBoard();\n\t}, []);\n\n\tconst onCellClick = (index: number) => {\n\t\tsetCells((prevCells => {\n\t\t\t// in case cell has been clicked before\n\t\t\tif (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n\n\t\t\tconst newCells = [...prevCells];\n\n\t\t\tnewCells[index] = {\n\t\t\t\t...prevCells[index],\n\t\t\t\ttakenByPlayer: ` ${player}`\n\t\t\t}\n\n\t\t\tsetNumMoves(prevNum => prevNum + 1);\n\t\t\tsetLastCell(index);\n\n\t\t\treturn newCells;\n\t\t}));\n\n\t};\n\n\tuseEffect(() => {\n\t\t//TEST\n\t\tif (lastCell === -1) return; // do not run after app starts\n\n\t\tconst result: boolean | number[] = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\t\t\n\t\tif (result && Array.isArray(result)) {\n\t\t\tsetIsWinner(true);\n\t\t\tscoreHandler(player);\n\t\t\tsetCells((prevCells) => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\t\t\tresult.forEach(cell => {\n\t\t\t\t\tnewCells[cell] = {\n\t\t\t\t\t\t...prevCells[cell],\n\t\t\t\t\t\twinning: true,\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\t//console.log(checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK));\n\t\t\n\n\t\t// check for draw\n\t\tif (numMoves === dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS) {\n\t\t\tsetIsDraw(true);\n\t\t\treturn;\n\t\t};\n\n\t\tsetPlayer((prevPlayer) => {\n\t\t\tif (prevPlayer === 'x') return 'o';\n\t\t\treturn 'x';\n\t\t});\n\n\t}, [lastCell]);\n\n\t//AI move\n\tuseEffect(() => {\n\t\tif (player === 'o' && isAI) {\n\n\t\t\tsetCells((prevCells => {\n\t\t\t\t// in case cell has been clicked before\n\t\t\t\t// forAI\n\t\t\t\tconst boardData = {\n\t\t\t\t\tcells: prevCells,\n\t\t\t\t\tcurrentPlayer: 'o',\n\t\t\t\t\tsize: dimensions.BOARD_NUM_ROWS,\n\t\t\t\t\tlastCellIndex: lastCell,\n\t\t\t\t\twinStreak: dimensions.WIN_STREAK\n\t\t\t\t}\n\n\t\t\t\tconst index = findBestMove(boardData);\n\t\n\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\tnewCells[index] = {\n\t\t\t\t\t...prevCells[index],\n\t\t\t\t\ttakenByPlayer: ' o'\n\t\t\t\t}\n\n\t\t\t\tsetNumMoves(prevNum => prevNum + 1);\n\t\t\t\tsetLastCell(index);\n\t\n\t\t\t\treturn newCells;\n\t\t\t}));\n\t\t}\n\t}, [player]);\n\n\treturn (\n\t\t<>\n\t\t\t<div className={`board board_${dimensions.BOARD_NUM_ROWS}`}>\n\t\t\t\t{cells.map((cell, pos) => (\n\t\t\t\t\t<Cell\n\t\t\t\t\t\tkey={pos}\n\t\t\t\t\t\tindex={pos}\n\t\t\t\t\t\tshowClassName={cell.showClassName}\n\t\t\t\t\t\ttakenByPlayer={cell.takenByPlayer}\n\t\t\t\t\t\twinning={cell.winning}\n\t\t\t\t\t\tcurrentPlayer={` current_${player}`}\n\t\t\t\t\t\tsize={dimensions.SIZE}\n\t\t\t\t\t\tonClickCallback={onCellClick}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t\t<Modal isWinner={isWinner} isDraw={isDraw} winner={player} />\n\t\t</>\n\t)\n};\n\nexport default Board;"]},"metadata":{},"sourceType":"module"}