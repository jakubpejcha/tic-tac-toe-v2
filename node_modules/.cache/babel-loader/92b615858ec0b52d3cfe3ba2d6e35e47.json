{"ast":null,"code":"var _jsxFileName = \"/home/jakub/Projects/tic-tac-toe/src/Board.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport Cell from './Cell';\nimport { checkWinner } from './checkWinner';\nimport { findBestMove } from './minimax';\nimport Modal from './Modal';\nimport './styles/Board.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst getDimensions = numRows => {\n  const dimensions = {\n    BOARD_NUM_ROWS: numRows,\n    SIZE: '',\n    DELAY: 0,\n    WIN_STREAK: 0\n  };\n  if (numRows === 3) dimensions.SIZE = '--small';\n  if (numRows === 10) dimensions.SIZE = '--large';\n  if (numRows === 3) dimensions.DELAY = 150;\n  if (numRows === 10) dimensions.DELAY = 10;\n  dimensions.WIN_STREAK = numRows >= 5 ? 5 : numRows;\n  return dimensions;\n};\n\nconst Board = ({\n  scoreHandler,\n  restart,\n  unsetRestart\n}) => {\n  _s();\n\n  const dimensions = getDimensions(3);\n  const [isWinner, setIsWinner] = useState(false);\n  const [isDraw, setIsDraw] = useState(false);\n  const [numMoves, setNumMoves] = useState(0);\n  const [player, setPlayer] = useState('x');\n  const [cells, setCells] = useState(Array(dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS).fill({\n    showClassName: '',\n    takenByPlayer: '',\n    winning: false\n  }));\n  const [lastCell, setLastCell] = useState(-1); // restart board\n\n  useEffect(() => {\n    setIsWinner(false);\n    setIsDraw(false);\n    setNumMoves(0);\n    setPlayer('x');\n    cells.forEach((cell, index) => {\n      setCells(prevCells => {\n        const newCells = [...prevCells];\n        newCells[index] = { ...cell,\n          takenByPlayer: '',\n          winning: false\n        };\n        return newCells;\n      });\n    });\n    setLastCell(-1);\n    unsetRestart();\n  }, [restart]); // Nice animation of creating the board\n\n  const showBoard = () => {\n    cells.forEach((cell, index) => {\n      setTimeout(() => {\n        setCells(prevCells => {\n          const newCells = [...prevCells];\n          newCells[index] = { ...cell,\n            showClassName: ' show'\n          };\n          return newCells;\n        });\n      }, index * dimensions.DELAY);\n    });\n  };\n\n  useEffect(() => {\n    showBoard();\n  }, []);\n\n  const onCellClick = index => {\n    const result = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\n    if (result && Array.isArray(result)) {\n      setIsWinner(true);\n      scoreHandler(player);\n      setCells(prevCells => {\n        const newCells = [...prevCells];\n        result.forEach(cell => {\n          newCells[cell] = { ...prevCells[cell],\n            winning: true\n          };\n        });\n        return newCells;\n      });\n      return;\n    } //if (player === 'o') setPlayer('x');\n\n\n    setCells(prevCells => {\n      // in case cell has been clicked before\n      if (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n      const newCells = [...prevCells];\n      newCells[index] = { ...prevCells[index],\n        takenByPlayer: ` ${player}`\n      }; // forAI\n\n      const boardData = {\n        cells: newCells,\n        currentPlayer: 'o',\n        size: dimensions.BOARD_NUM_ROWS,\n        lastCellIndex: index,\n        winStreak: dimensions.WIN_STREAK\n      };\n      const opponentIndex = findBestMove(boardData);\n      newCells[opponentIndex] = { ...prevCells[opponentIndex],\n        takenByPlayer: 'o'\n      };\n      setNumMoves(prevNum => prevNum + 1);\n      setNumMoves(prevNum => prevNum + 2); //setLastCell(index);\n\n      setLastCell(opponentIndex);\n      return newCells;\n    }); //setPlayer('o');\n  }; // useEffect(() => {\n  // \t//TEST\n  // \tif (lastCell === -1) return; // do not run after app starts\n  // \tconst result: boolean | number[] = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n  // \tconst boardData = {\n  // \t\tcells: cells,\n  // \t\tcurrentPlayer: player,\n  // \t\tsize: dimensions.BOARD_NUM_ROWS,\n  // \t\tlastCellIndex: lastCell,\n  // \t\twinStreak: dimensions.WIN_STREAK\n  // \t}\n  // \tif (result && Array.isArray(result)) {\n  // \t\tsetIsWinner(true);\n  // \t\tscoreHandler(player);\n  // \t\tsetCells((prevCells) => {\n  // \t\t\tconst newCells = [...prevCells];\n  // \t\t\tresult.forEach(cell => {\n  // \t\t\t\tnewCells[cell] = {\n  // \t\t\t\t\t...prevCells[cell],\n  // \t\t\t\t\twinning: true,\n  // \t\t\t\t};\n  // \t\t\t});\n  // \t\t\treturn newCells;\n  // \t\t});\n  // \t\treturn;\n  // \t}\n  // \t//console.log(checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK));\n  // \t// check for draw\n  // \tif (numMoves === dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS) {\n  // \t\tsetIsDraw(true);\n  // \t\treturn;\n  // \t};\n  // \t// setPlayer((prevPlayer) => {\n  // \t// \tif (prevPlayer === 'x') return 'o';\n  // \t// \treturn 'x';\n  // \t// });\n  // \tboardData.currentPlayer = 'o';\n  // \tconsole.log(findBestMove(boardData));\n  // \tsetCells((prevCells => {\n  // \t\t// in case cell has been clicked before\n  // \t\tconst index = findBestMove(boardData);\n  // \t\t//if (index === null) return prevCells;\n  // \t\t//if (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n  // \t\tconst newCells = [...prevCells];\n  // \t\tnewCells[index] = {\n  // \t\t\t...prevCells[index],\n  // \t\t\ttakenByPlayer: 'o'\n  // \t\t}\n  // \t\tsetNumMoves(prevNum => prevNum + 1);\n  // \t\t//setLastCell(index);\n  // \t\treturn newCells;\n  // \t}));\n  // }, [lastCell]);\n\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: `board board_${dimensions.BOARD_NUM_ROWS}`,\n      children: cells.map((cell, pos) => /*#__PURE__*/_jsxDEV(Cell, {\n        index: pos,\n        showClassName: cell.showClassName,\n        takenByPlayer: cell.takenByPlayer,\n        winning: cell.winning,\n        currentPlayer: ` current_${player}`,\n        size: dimensions.SIZE,\n        onClickCallback: onCellClick\n      }, pos, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 6\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 242,\n      columnNumber: 4\n    }, this), /*#__PURE__*/_jsxDEV(Modal, {\n      isWinner: isWinner,\n      isDraw: isDraw,\n      winner: player\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 4\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Board, \"QNsKdsnjX14aZZyS1VeaWGjNabo=\");\n\n_c = Board;\nexport default Board;\n\nvar _c;\n\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/Board.tsx"],"names":["React","useState","useEffect","Cell","checkWinner","findBestMove","Modal","getDimensions","numRows","dimensions","BOARD_NUM_ROWS","SIZE","DELAY","WIN_STREAK","Board","scoreHandler","restart","unsetRestart","isWinner","setIsWinner","isDraw","setIsDraw","numMoves","setNumMoves","player","setPlayer","cells","setCells","Array","fill","showClassName","takenByPlayer","winning","lastCell","setLastCell","forEach","cell","index","prevCells","newCells","showBoard","setTimeout","onCellClick","result","isArray","boardData","currentPlayer","size","lastCellIndex","winStreak","opponentIndex","prevNum","map","pos"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport Cell from './Cell';\nimport { CellInterface } from './shared/interfaces';\nimport { checkWinner } from './checkWinner';\nimport { findBestMove } from './minimax';\nimport Modal from './Modal';\nimport './styles/Board.css';\n\ninterface Dimensions {\n\tBOARD_NUM_ROWS: number,\n\tSIZE: string,\n\tDELAY: number,\n\tWIN_STREAK: number\n}\n\nconst getDimensions = (numRows: number): Dimensions => {\n\tconst dimensions = {\n\t\tBOARD_NUM_ROWS: numRows,\n\t\tSIZE: '',\n\t\tDELAY: 0,\n\t\tWIN_STREAK: 0\n\t}\n\n\tif (numRows === 3) dimensions.SIZE = '--small';\n\tif (numRows === 10) dimensions.SIZE = '--large';\n\n\tif (numRows === 3) dimensions.DELAY = 150;\n\tif (numRows === 10) dimensions.DELAY = 10;\n\n\tdimensions.WIN_STREAK = numRows >= 5 ? 5 : numRows;\n\n\treturn dimensions;\n}\n\ninterface Props {\n\tscoreHandler: (updatePlayer: string) => void,\n\trestart: boolean,\n\tunsetRestart: () => void,\n}\n\nconst Board = ({ scoreHandler, restart, unsetRestart }: Props) => {\n\n\tconst dimensions = getDimensions(3);\n\n\tconst [isWinner, setIsWinner] = useState(false);\n\n\tconst [isDraw, setIsDraw] = useState(false);\n\n\tconst [numMoves, setNumMoves] = useState(0);\n\n\tconst [player, setPlayer] = useState('x');\n\n\tconst [cells, setCells] = useState<CellInterface[]>(Array(dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS).fill({\n\t\tshowClassName: '',\n\t\ttakenByPlayer: '',\n\t\twinning: false,\n\t}));\n\n\tconst [lastCell, setLastCell] = useState(-1);\n\n\t// restart board\n\tuseEffect(() => {\n\t\tsetIsWinner(false);\n\t\tsetIsDraw(false);\n\t\tsetNumMoves(0);\n\t\tsetPlayer('x');\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetCells(prevCells => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\tnewCells[index] = {\n\t\t\t\t\t...cell,\n\t\t\t\t\ttakenByPlayer: '',\n\t\t\t\t\twinning: false\n\t\t\t\t}\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t});\n\t\t\n\t\tsetLastCell(-1);\n\t\tunsetRestart();\n\t}, [restart]);\n\n\t// Nice animation of creating the board\n\tconst showBoard = () => {\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetCells((prevCells) => {\n\t\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\t\tnewCells[index] = {\n\t\t\t\t\t\t...cell,\n\t\t\t\t\t\tshowClassName: ' show'\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn newCells;\n\t\t\t\t});\n\t\t\t}, index * dimensions.DELAY);\n\t\t});\n\t};\n\n\tuseEffect(() => {\n\t\tshowBoard();\n\t}, []);\n\n\tconst onCellClick = (index: number) => {\n\n\t\tconst result: boolean | number[] = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\n\t\tif (result && Array.isArray(result)) {\n\t\t\tsetIsWinner(true);\n\t\t\tscoreHandler(player);\n\t\t\tsetCells((prevCells) => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\t\t\tresult.forEach(cell => {\n\t\t\t\t\tnewCells[cell] = {\n\t\t\t\t\t\t...prevCells[cell],\n\t\t\t\t\t\twinning: true,\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t//if (player === 'o') setPlayer('x');\n\n\t\tsetCells((prevCells => {\n\t\t\t// in case cell has been clicked before\n\t\t\tif (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n\n\t\t\tconst newCells = [...prevCells];\n\n\t\t\tnewCells[index] = {\n\t\t\t\t...prevCells[index],\n\t\t\t\ttakenByPlayer: ` ${player}`\n\t\t\t}\n\n\t\t\t// forAI\n\t\t\tconst boardData = {\n\t\t\t\tcells: newCells,\n\t\t\t\tcurrentPlayer: 'o',\n\t\t\t\tsize: dimensions.BOARD_NUM_ROWS,\n\t\t\t\tlastCellIndex: index,\n\t\t\t\twinStreak: dimensions.WIN_STREAK\n\t\t\t}\n\n\t\t\tconst opponentIndex = findBestMove(boardData);\n\t\t\tnewCells[opponentIndex] = {\n\t\t\t\t...prevCells[opponentIndex],\n\t\t\t\ttakenByPlayer: 'o'\n\t\t\t}\n\n\t\t\tsetNumMoves(prevNum => prevNum + 1);\n\t\t\tsetNumMoves(prevNum => prevNum + 2);\n\t\t\t//setLastCell(index);\n\t\t\tsetLastCell(opponentIndex);\n\n\t\t\treturn newCells;\n\t\t}));\n\n\t\t//setPlayer('o');\n\t};\n\n\t// useEffect(() => {\n\t// \t//TEST\n\t// \tif (lastCell === -1) return; // do not run after app starts\n\n\t// \tconst result: boolean | number[] = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\t// \tconst boardData = {\n\t// \t\tcells: cells,\n\t// \t\tcurrentPlayer: player,\n\t// \t\tsize: dimensions.BOARD_NUM_ROWS,\n\t// \t\tlastCellIndex: lastCell,\n\t// \t\twinStreak: dimensions.WIN_STREAK\n\t// \t}\n\t\t\n\t\t\n\t\t\n\t// \tif (result && Array.isArray(result)) {\n\t// \t\tsetIsWinner(true);\n\t// \t\tscoreHandler(player);\n\t// \t\tsetCells((prevCells) => {\n\t// \t\t\tconst newCells = [...prevCells];\n\t// \t\t\tresult.forEach(cell => {\n\t// \t\t\t\tnewCells[cell] = {\n\t// \t\t\t\t\t...prevCells[cell],\n\t// \t\t\t\t\twinning: true,\n\t// \t\t\t\t};\n\t// \t\t\t});\n\n\t// \t\t\treturn newCells;\n\t// \t\t});\n\t// \t\treturn;\n\t// \t}\n\t// \t//console.log(checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK));\n\t\t\n\n\t// \t// check for draw\n\t// \tif (numMoves === dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS) {\n\t// \t\tsetIsDraw(true);\n\t// \t\treturn;\n\t// \t};\n\n\t// \t// setPlayer((prevPlayer) => {\n\t// \t// \tif (prevPlayer === 'x') return 'o';\n\t// \t// \treturn 'x';\n\t// \t// });\n\n\t// \tboardData.currentPlayer = 'o';\n\t// \tconsole.log(findBestMove(boardData));\n\n\t// \tsetCells((prevCells => {\n\t// \t\t// in case cell has been clicked before\n\t// \t\tconst index = findBestMove(boardData);\n\n\t// \t\t//if (index === null) return prevCells;\n\t// \t\t//if (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n\n\t// \t\tconst newCells = [...prevCells];\n\n\t// \t\tnewCells[index] = {\n\t// \t\t\t...prevCells[index],\n\t// \t\t\ttakenByPlayer: 'o'\n\t// \t\t}\n\n\t// \t\tsetNumMoves(prevNum => prevNum + 1);\n\t// \t\t//setLastCell(index);\n\n\t// \t\treturn newCells;\n\t// \t}));\n\t\t\n\n\t// }, [lastCell]);\n\n\treturn (\n\t\t<>\n\t\t\t<div className={`board board_${dimensions.BOARD_NUM_ROWS}`}>\n\t\t\t\t{cells.map((cell, pos) => (\n\t\t\t\t\t<Cell\n\t\t\t\t\t\tkey={pos}\n\t\t\t\t\t\tindex={pos}\n\t\t\t\t\t\tshowClassName={cell.showClassName}\n\t\t\t\t\t\ttakenByPlayer={cell.takenByPlayer}\n\t\t\t\t\t\twinning={cell.winning}\n\t\t\t\t\t\tcurrentPlayer={` current_${player}`}\n\t\t\t\t\t\tsize={dimensions.SIZE}\n\t\t\t\t\t\tonClickCallback={onCellClick}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t\t<Modal isWinner={isWinner} isDraw={isDraw} winner={player} />\n\t\t</>\n\t)\n};\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}