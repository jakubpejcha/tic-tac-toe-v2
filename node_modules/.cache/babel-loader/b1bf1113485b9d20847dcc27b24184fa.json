{"ast":null,"code":"import { checkWinner } from './checkWinner';\n\nconst evaluateBoard = (result, isMaximizer) => {\n  console.log(result);\n\n  if (!result) {\n    return 0;\n  } else if (isMaximizer) {\n    return 10;\n  } else {\n    return -10;\n  }\n};\n\nconst isMovesLeft = cells => {\n  cells.forEach(cell => {\n    if (cell.takenByPlayer === '') return true;\n  });\n  return false;\n};\n\nconst swapPlayers = currentPlayer => {\n  if (currentPlayer === 'x') return 'o';\n  return 'x';\n};\n\n// cells will be a copy\nconst minimax = (depth, boardData, isMaximizer) => {\n  const {\n    cells: cellsCopy,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData;\n  const result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n  const boardScore = evaluateBoard(result, isMaximizer); //console.log(boardScore);\n\n  if (boardScore === 10) return boardScore;\n  if (boardScore === -10) return boardScore;\n  if (!isMovesLeft(cellsCopy)) return 0; // do not modify cells\n  //const cellsCopy = [...cells];\n\n  let best = -100;\n\n  if (isMaximizer) {\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = swapPlayers(currentPlayer);\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n        cell.takenByPlayer = '';\n      }\n    });\n  } else {\n    best = 100;\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = swapPlayers(currentPlayer);\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n        cell.takenByPlayer = '';\n      }\n    });\n  }\n\n  return best;\n};\n\nexport const findBestMove = boardData => {\n  const {\n    cells,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData;\n  const cellsCopy = [...cells];\n  const boardDataCopy = { ...boardData,\n    cells: cellsCopy\n  };\n  let bestValue = -100;\n  let bestMove = -1;\n  boardDataCopy.cells.forEach((cell, index) => {\n    if (cell.takenByPlayer === '') {\n      cell.takenByPlayer = currentPlayer;\n      const newBoardData = { ...boardDataCopy,\n        lastCellIndex: index\n      };\n      let moveValue = minimax(0, newBoardData, false);\n      console.log(moveValue);\n      cell.takenByPlayer = '';\n\n      if (moveValue > bestValue) {\n        bestValue = moveValue;\n        bestMove = index;\n      }\n    }\n  });\n  return bestMove;\n};","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/minimax.ts"],"names":["checkWinner","evaluateBoard","result","isMaximizer","console","log","isMovesLeft","cells","forEach","cell","takenByPlayer","swapPlayers","currentPlayer","minimax","depth","boardData","cellsCopy","size","lastCellIndex","winStreak","boardScore","best","index","newBoardData","Math","max","min","findBestMove","boardDataCopy","bestValue","bestMove","moveValue"],"mappings":"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","sourcesContent":["import { checkWinner } from './checkWinner';\nimport { CellInterface } from './shared/interfaces';\n\nconst evaluateBoard = (result: boolean | number[], isMaximizer: boolean): number => {\n\tconsole.log(result);\n\t\n\tif (!result) {\n\t\treturn 0;\n\t} else if (isMaximizer) {\n\t\treturn 10;\n\t} else {\n\t\treturn -10;\n\t}\n}\n\nconst isMovesLeft = (cells: CellInterface[]) => {\n\tcells.forEach(cell => {\n\t\tif (cell.takenByPlayer === '') return true;\n\t});\n\treturn false;\n}\n\nconst swapPlayers = (currentPlayer: string) => {\n\tif (currentPlayer === 'x') return 'o';\n\treturn 'x';\n}\n\ninterface BoardData {\n\tcells: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tlastCellIndex: number,\n\twinStreak: number\n}\n\n// cells will be a copy\nconst minimax = (depth: number, boardData: BoardData, isMaximizer: boolean): number => {\n\tconst {cells: cellsCopy, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n\tconst boardScore = evaluateBoard(result, isMaximizer);\n\t//console.log(boardScore);\n\t\n\n\tif (boardScore === 10) return boardScore;\n\tif (boardScore === -10) return boardScore;\n\tif (!isMovesLeft(cellsCopy)) return 0;\n\n\t// do not modify cells\n\t//const cellsCopy = [...cells];\n\tlet best = -100;\n\n\tif (isMaximizer) {\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\n\t} else {\n\t\tbest = 100;\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\t}\n\n\treturn best;\n}\n\nexport const findBestMove = (boardData: BoardData):number => {\n\tconst {cells, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst cellsCopy = [...cells];\n\tconst boardDataCopy = {\n\t\t...boardData,\n\t\tcells: cellsCopy,\n\t};\n\n\tlet bestValue = -100;\n\tlet bestMove = -1;\n\t\n\tboardDataCopy.cells.forEach((cell, index) => {\n\t\tif (cell.takenByPlayer === '') {\n\t\t\tcell.takenByPlayer = currentPlayer;\n\n\t\t\tconst newBoardData = {\n\t\t\t\t...boardDataCopy,\n\t\t\t\tlastCellIndex: index,\n\t\t\t}\n\n\t\t\tlet moveValue = minimax(0, newBoardData, false);\n\t\t\tconsole.log(moveValue);\n\t\t\t\n\n\t\t\tcell.takenByPlayer = '';\n\n\t\t\tif (moveValue > bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn bestMove;\n}"]},"metadata":{},"sourceType":"module"}