{"ast":null,"code":"import _toConsumableArray from\"/home/jakub/Projects/tic-tac-toe/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/home/jakub/Projects/tic-tac-toe/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _createForOfIteratorHelper from\"/home/jakub/Projects/tic-tac-toe/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{checkWinner}from'./checkWinner';var evaluateBoard=function evaluateBoard(result,isMaximizer){if(!result){return 0;}else if(isMaximizer){return 10;}else{return-10;}};var isMovesLeft=function isMovesLeft(cells){var _iterator=_createForOfIteratorHelper(cells),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var cell=_step.value;if(cell.takenByPlayer==='')return true;}}catch(err){_iterator.e(err);}finally{_iterator.f();}return false;};var swapPlayers=function swapPlayers(currentPlayer){if(currentPlayer==='x')return'o';return'x';};// cells will be a copy\nvar minimax=function minimax(depth,boardData,isMaximizer){var cellsCopy=boardData.cells,currentPlayer=boardData.currentPlayer,size=boardData.size,lastCellIndex=boardData.lastCellIndex,winStreak=boardData.winStreak;var result=checkWinner(cellsCopy,currentPlayer,size,lastCellIndex,winStreak);var boardScore=evaluateBoard(result,isMaximizer);if(boardScore===10)return boardScore;if(boardScore===-10)return boardScore;if(!isMovesLeft(cellsCopy))return 0;// do not modify cells\nvar best=-100;if(isMaximizer){cellsCopy.forEach(function(cell,index){if(cell.takenByPlayer===''){cell.takenByPlayer=swapPlayers(currentPlayer);//console.log(cellsCopy[index].takenByPlayer);\nvar newBoardData=_objectSpread(_objectSpread({},boardData),{},{cells:cellsCopy,currentPlayer:swapPlayers(currentPlayer),lastCellIndex:index});best=Math.max(best,minimax(depth+1,newBoardData,!isMaximizer));cell.takenByPlayer='';}});}else{best=100;cellsCopy.forEach(function(cell,index){if(cell.takenByPlayer===''){cell.takenByPlayer=swapPlayers(currentPlayer);var newBoardData=_objectSpread(_objectSpread({},boardData),{},{cells:cellsCopy,currentPlayer:swapPlayers(currentPlayer),lastCellIndex:index});best=Math.min(best,minimax(depth+1,newBoardData,!isMaximizer));cell.takenByPlayer='';}});}return best;};export var findBestMove=function findBestMove(boardData){var cells=boardData.cells,currentPlayer=boardData.currentPlayer,size=boardData.size,lastCellIndex=boardData.lastCellIndex,winStreak=boardData.winStreak;var cellsCopy=_toConsumableArray(cells);var boardDataCopy=_objectSpread(_objectSpread({},boardData),{},{cells:cellsCopy});console.log('called finder');var bestValue=-100;var bestMove=-1;boardDataCopy.cells.forEach(function(cell,index){if(cell.takenByPlayer===''){cell.takenByPlayer=currentPlayer;boardDataCopy.lastCellIndex=index;console.time('minimax');var moveValue=minimax(0,boardDataCopy,true);console.timeEnd('minimax');cell.takenByPlayer='';if(moveValue>bestValue){bestValue=moveValue;bestMove=index;}}});return bestMove;};","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/minimax.ts"],"names":["checkWinner","evaluateBoard","result","isMaximizer","isMovesLeft","cells","cell","takenByPlayer","swapPlayers","currentPlayer","minimax","depth","boardData","cellsCopy","size","lastCellIndex","winStreak","boardScore","best","forEach","index","newBoardData","Math","max","min","findBestMove","boardDataCopy","console","log","bestValue","bestMove","time","moveValue","timeEnd"],"mappings":"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","sourcesContent":["import { checkWinner } from './checkWinner';\nimport { CellInterface } from './shared/interfaces';\n\nconst evaluateBoard = (result: boolean | number[], isMaximizer: boolean): number => {\n\n\tif (!result) {\n\t\treturn 0;\n\t} else if (isMaximizer) {\n\t\treturn 10;\n\t} else {\n\t\treturn -10;\n\t}\n}\n\nconst isMovesLeft = (cells: CellInterface[]) => {\n\tfor (const cell of cells) {\n\t\tif (cell.takenByPlayer === '') return true;\n\t}\n\treturn false;\n}\n\nconst swapPlayers = (currentPlayer: string) => {\n\tif (currentPlayer === 'x') return 'o';\n\treturn 'x';\n}\n\ninterface BoardData {\n\tcells: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tlastCellIndex: number,\n\twinStreak: number\n}\n\n// cells will be a copy\nconst minimax = (depth: number, boardData: BoardData, isMaximizer: boolean): number => {\n\tconst {cells: cellsCopy, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n\tconst boardScore = evaluateBoard(result, isMaximizer);\n\t\n\n\tif (boardScore === 10) return boardScore;\n\tif (boardScore === -10) return boardScore;\n\tif (!isMovesLeft(cellsCopy)) return 0;\n\n\t// do not modify cells\n\tlet best = -100;\n\n\tif (isMaximizer) {\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\t\t\t\t//console.log(cellsCopy[index].takenByPlayer);\n\t\t\t\t\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\n\t} else {\n\t\tbest = 100;\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\t}\n\n\treturn best;\n}\n\nexport const findBestMove = (boardData: BoardData):number => {\n\tconst {cells, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst cellsCopy = [...cells];\n\tconst boardDataCopy = {\n\t\t...boardData,\n\t\tcells: cellsCopy,\n\t};\n\tconsole.log('called finder');\n\t\n\tlet bestValue = -100;\n\tlet bestMove = -1;\n\t\n\tboardDataCopy.cells.forEach((cell, index) => {\t\n\t\tif (cell.takenByPlayer === '') {\n\t\t\tcell.takenByPlayer = currentPlayer;\n\t\t\tboardDataCopy.lastCellIndex = index;\n\n\t\t\tconsole.time('minimax')\n\t\t\tlet moveValue = minimax(0, boardDataCopy, true);\n\t\t\tconsole.timeEnd('minimax')\n\t\t\t\n\n\t\t\tcell.takenByPlayer = '';\n\n\t\t\tif (moveValue > bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn bestMove;\n}"]},"metadata":{},"sourceType":"module"}