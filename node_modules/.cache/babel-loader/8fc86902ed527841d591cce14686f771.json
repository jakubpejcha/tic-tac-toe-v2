{"ast":null,"code":"const getColumn = (size, index, winStreak) => {\n  const rowNumber = Math.floor(index / size) + 1;\n  const offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n  const offsetDown = size - rowNumber < winStreak ? size - rowNumber : winStreak - 1;\n  let column = []; // up\n\n  for (let i = offsetUp; i > 0; i--) {\n    column.push(index - i * size);\n  }\n\n  column.push(index); //down\n\n  for (let i = 1; i <= offsetDown; i++) {\n    column.push(index + i * size);\n  }\n\n  return column;\n};\n\nconst getRow = (size, index, winStreak) => {\n  const columnNumber = index % size + 1;\n  const offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n  const offsetRight = size - columnNumber < winStreak ? size - columnNumber : winStreak - 1;\n  let row = []; // left\n\n  for (let i = offsetLeft; i > 0; i--) {\n    row.push(index - i);\n  }\n\n  row.push(index); //down\n\n  for (let i = 1; i <= offsetRight; i++) {\n    row.push(index + i);\n  }\n\n  return row;\n};\n\nconst getDiagonalUpRight = (size, index, winStreak) => {\n  const rowNumber = Math.floor(index / size) + 1;\n  const columnNumber = index % size + 1;\n  const offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n  const offsetDown = size - rowNumber < winStreak ? size - rowNumber : winStreak - 1;\n  const offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n  const offsetRight = size - columnNumber < winStreak ? size - columnNumber : winStreak - 1; // guard column\n\n  let diagonal = []; // up-right below\n\n  for (let i = offsetDown; i > 0; i--) {\n    if (i > offsetLeft) continue;\n    diagonal.push(index + i * size - i);\n  }\n\n  diagonal.push(index); // up-right above\n\n  for (let i = 1; i <= offsetUp; i++) {\n    if (i > offsetRight) break;\n    diagonal.push(index - i * size + i);\n  }\n\n  return diagonal;\n};\n\nconst getDiagonalDownRight = (size, index, winStreak) => {\n  const rowNumber = Math.floor(index / size) + 1;\n  const columnNumber = index % size + 1;\n  const offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n  const offsetDown = size - rowNumber < winStreak ? size - rowNumber : winStreak - 1;\n  const offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n  const offsetRight = size - columnNumber < winStreak ? size - columnNumber : winStreak - 1;\n  let diagonal = []; // down-right above\n\n  for (let i = offsetUp; i > 0; i--) {\n    if (i > offsetLeft) continue;\n    diagonal.push(index - i * size - i);\n  }\n\n  diagonal.push(index); // down-right below\n\n  for (let i = 1; i <= offsetDown; i++) {\n    if (i > offsetRight) break;\n    diagonal.push(index + i * size + i);\n  }\n\n  return diagonal;\n};\n\nconst checkMoves = (array, currentPlayer, size, index, winStreak, callbackDirection) => {\n  const direction = callbackDirection(size, index, winStreak);\n  let streak = 0;\n  const winningCells = [];\n  const length = direction.length;\n\n  for (let i = 0; i < length; i++) {\n    streak++;\n    winningCells.push(direction[i]);\n\n    if (array[direction[i]].takenByPlayer === '' || array[direction[i]].takenByPlayer.trim() !== currentPlayer) {\n      streak = 0;\n      winningCells.length = 0;\n    }\n\n    ;\n    if (streak === winStreak) return winningCells;\n  }\n\n  return false;\n};\n\nexport const checkWinner = (array, currentPlayer, size, index, winStreak) => {\n  if (index === -1) return false;\n  return checkMoves(array, currentPlayer, size, index, winStreak, getColumn) || checkMoves(array, currentPlayer, size, index, winStreak, getRow) || checkMoves(array, currentPlayer, size, index, winStreak, getDiagonalUpRight) || checkMoves(array, currentPlayer, size, index, winStreak, getDiagonalDownRight) || false;\n};","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/checkWinner.ts"],"names":["getColumn","size","index","winStreak","rowNumber","Math","floor","offsetUp","offsetDown","column","i","push","getRow","columnNumber","offsetLeft","offsetRight","row","getDiagonalUpRight","diagonal","getDiagonalDownRight","checkMoves","array","currentPlayer","callbackDirection","direction","streak","winningCells","length","takenByPlayer","trim","checkWinner"],"mappings":"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","sourcesContent":["import { CellInterface } from './shared/interfaces';\n\nconst getColumn = (size: number, index: number, winStreak: number): number[] => {\n\tconst rowNumber = Math.floor(index / size) + 1;\n\n\tconst offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n\tconst offsetDown = (size - rowNumber) < winStreak ? (size - rowNumber) : winStreak - 1;\n\n\tlet column: number[] = [];\n\t// up\n\tfor (let i = offsetUp; i > 0; i--) {\n\t\tcolumn.push(index - (i * size));\n\t}\n\n\tcolumn.push(index);\n\n\t//down\n\tfor (let i = 1; i <= offsetDown; i++) {\n\t\tcolumn.push(index + (i * size));\n\t}\n\n\treturn column;\n}\n\nconst getRow = (size: number, index: number, winStreak: number): number[] => {\n\tconst columnNumber = (index % size) + 1;\n\n\tconst offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n\tconst offsetRight = (size - columnNumber) < winStreak ? (size - columnNumber) : winStreak - 1;\n\n\tlet row: number[] = [];\n\t// left\n\tfor (let i = offsetLeft; i > 0; i--) {\n\t\trow.push(index - i);\n\t}\n\n\trow.push(index);\n\n\t//down\n\tfor (let i = 1; i <= offsetRight; i++) {\n\t\trow.push(index + i);\n\t}\n\n\treturn row;\n}\n\nconst getDiagonalUpRight = (size: number, index: number, winStreak: number): number[] => {\n\tconst rowNumber = Math.floor(index / size) + 1;\n\tconst columnNumber = (index % size) + 1;\n\n\tconst offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n\tconst offsetDown = (size - rowNumber) < winStreak ? (size - rowNumber) : winStreak - 1;\n\n\tconst offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n\tconst offsetRight = (size - columnNumber) < winStreak ? (size - columnNumber) : winStreak - 1;\n\n\t// guard column\n\n\tlet diagonal: number[] = [];\n\t// up-right below\n\tfor (let i = offsetDown; i > 0; i--) {\n\t\tif (i > offsetLeft) continue;\n\t\tdiagonal.push(index + (i * size) - i);\n\t}\n\n\tdiagonal.push(index);\n\n\t// up-right above\n\tfor (let i = 1; i <= offsetUp; i++) {\n\t\tif (i > offsetRight) break;\n\t\tdiagonal.push(index - (i * size) + i);\n\t}\n\n\treturn diagonal;\n}\n\nconst getDiagonalDownRight = (size: number, index: number, winStreak: number): number[] => {\n\tconst rowNumber = Math.floor(index / size) + 1;\n\tconst columnNumber = (index % size) + 1;\n\n\tconst offsetUp = rowNumber < winStreak ? rowNumber - 1 : winStreak - 1;\n\tconst offsetDown = (size - rowNumber) < winStreak ? (size - rowNumber) : winStreak - 1;\n\n\tconst offsetLeft = columnNumber < winStreak ? columnNumber - 1 : winStreak - 1;\n\tconst offsetRight = (size - columnNumber) < winStreak ? (size - columnNumber) : winStreak - 1;\n\n\tlet diagonal: number[] = [];\n\t// down-right above\n\tfor (let i = offsetUp; i > 0; i--) {\n\t\tif (i > offsetLeft) continue;\n\t\tdiagonal.push(index - (i * size) - i);\n\t}\n\n\tdiagonal.push(index);\n\n\t// down-right below\n\tfor (let i = 1; i <= offsetDown; i++) {\n\t\tif (i > offsetRight) break;\n\t\tdiagonal.push(index + (i * size) + i);\n\t}\n\n\treturn diagonal;\n}\n\nconst checkMoves = (\n\tarray: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tindex: number,\n\twinStreak: number,\n\tcallbackDirection: ((size: number, index: number, winStreak: number) => number[])\n): boolean | number[] => {\n\tconst direction = callbackDirection(size, index, winStreak);\n\t\n\tlet streak = 0;\n\tconst winningCells: number[] = [];\n\tconst length = direction.length;\n\t\n\tfor (let i = 0; i < length; i++) {\n\t\tstreak++;\n\t\twinningCells.push(direction[i]);\n\t\t\n\t\tif (array[direction[i]].takenByPlayer === '' || array[direction[i]].takenByPlayer.trim() !== currentPlayer) {\n\t\t\tstreak = 0;\n\t\t\twinningCells.length = 0;\n\t\t};\n\n\t\tif (streak === winStreak) return winningCells;\n\t\t\n\t}\n\t\n\treturn false;\n}\n\nexport const checkWinner = (\n\tarray: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tindex: number,\n\twinStreak: number\n): boolean | number[] => {\n\n\tif (index === -1) return false;\n\n\treturn (\n\t\tcheckMoves(array, currentPlayer, size, index, winStreak, getColumn) ||\n\t\tcheckMoves(array, currentPlayer, size, index, winStreak, getRow) ||\n\t\tcheckMoves(array, currentPlayer, size, index, winStreak, getDiagonalUpRight) ||\n\t\tcheckMoves(array, currentPlayer, size, index, winStreak, getDiagonalDownRight) ||\n\t\tfalse\n\t);\n\n}"]},"metadata":{},"sourceType":"module"}