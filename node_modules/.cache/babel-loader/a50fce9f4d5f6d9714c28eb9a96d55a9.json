{"ast":null,"code":"import { checkWinner } from './checkWinner';\n\nconst isMaximizer = player => {\n  if (player === 'x') return true;\n  return false;\n};\n\nconst evaluateBoard = (result, player) => {\n  if (!result) {\n    return 0;\n  } else if (isMaximizer(player)) {\n    return 10;\n  } else {\n    return -10;\n  }\n};\n\nconst isMovesLeft = cells => {\n  cells.forEach(cell => {\n    if (cell.takenByPlayer === '') return true;\n  });\n  return false;\n};\n\nconst swapPlayers = currentPlayer => {\n  if (currentPlayer === 'x') return 'o';\n  return 'x';\n};\n\n// cells will be a copy\nconst minimax = (depth, boardData) => {\n  const {\n    cells: cellsCopy,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData;\n  const result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n  const boardScore = evaluateBoard(result, currentPlayer);\n  if (boardScore === 10) return boardScore;\n  if (boardScore === -10) return boardScore;\n  if (!isMovesLeft(cellsCopy)) return 0; // do not modify cells\n  //const cellsCopy = [...cells];\n\n  let best = -100;\n\n  if (isMaximizer(currentPlayer)) {\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = currentPlayer;\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.max(best, minimax(depth + 1, newBoardData));\n        cell.takenByPlayer = '';\n      }\n    });\n  } else {\n    best = 100;\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = swapPlayers(currentPlayer);\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.min(best, minimax(depth + 1, newBoardData));\n        cell.takenByPlayer = '';\n      }\n    });\n  }\n\n  return best;\n};\n\nexport const findBestMove = boardData => {\n  const {\n    cells,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData; //if (currentPlayer !== AIPlayer) return null;\n\n  const cellsCopy = [...cells];\n  const boardDataCopy = { ...boardData,\n    cells: cellsCopy\n  };\n  let bestValue = isMaximizer(currentPlayer) ? -100 : 100;\n  let bestMove = -1;\n  boardDataCopy.cells.forEach((cell, index) => {\n    if (cell.takenByPlayer === '') {\n      cell.takenByPlayer = currentPlayer;\n      const newBoardData = { ...boardDataCopy,\n        currentPlayer: swapPlayers(currentPlayer),\n        lastCellIndex: index\n      };\n      let moveValue = minimax(0, newBoardData);\n      cell.takenByPlayer = '';\n\n      if (isMaximizer(currentPlayer) && moveValue > bestValue) {\n        bestValue = moveValue;\n        bestMove = index;\n      }\n\n      if (!isMaximizer(currentPlayer) && moveValue < bestValue) {\n        bestValue = moveValue;\n        bestMove = index;\n      }\n    }\n  });\n  return bestMove;\n};","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/minimax.ts"],"names":["checkWinner","isMaximizer","player","evaluateBoard","result","isMovesLeft","cells","forEach","cell","takenByPlayer","swapPlayers","currentPlayer","minimax","depth","boardData","cellsCopy","size","lastCellIndex","winStreak","boardScore","best","index","newBoardData","Math","max","min","findBestMove","boardDataCopy","bestValue","bestMove","moveValue"],"mappings":"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","sourcesContent":["import { checkWinner } from './checkWinner';\nimport { CellInterface } from './shared/interfaces';\n\nconst isMaximizer = (player: string) => {\n\tif (player === 'x') return true;\n\treturn false;\n}\n\nconst evaluateBoard = (result: boolean | number[], player: string): number => {\n\tif (!result) {\n\t\treturn 0;\n\t} else if (isMaximizer(player)) {\n\t\treturn 10;\n\t} else {\n\t\treturn -10;\n\t}\n}\n\nconst isMovesLeft = (cells: CellInterface[]) => {\n\tcells.forEach(cell => {\n\t\tif (cell.takenByPlayer === '') return true;\n\t});\n\treturn false;\n}\n\nconst swapPlayers = (currentPlayer: string) => {\n\tif (currentPlayer === 'x') return 'o';\n\treturn 'x';\n}\n\ninterface BoardData {\n\tcells: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tlastCellIndex: number,\n\twinStreak: number\n}\n\n// cells will be a copy\nconst minimax = (depth: number, boardData: BoardData): number => {\n\tconst {cells: cellsCopy, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n\tconst boardScore = evaluateBoard(result, currentPlayer);\n\n\tif (boardScore === 10) return boardScore;\n\tif (boardScore === -10) return boardScore;\n\tif (!isMovesLeft(cellsCopy)) return 0;\n\n\t// do not modify cells\n\t//const cellsCopy = [...cells];\n\tlet best = -100;\n\n\tif (isMaximizer(currentPlayer)) {\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\n\t\t\t\tcell.takenByPlayer = currentPlayer;\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.max(best, minimax(depth + 1, newBoardData));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\n\t} else {\n\t\tbest = 100;\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.min(best, minimax(depth + 1, newBoardData));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\t}\n\n\treturn best;\n}\n\nexport const findBestMove = (boardData: BoardData):number | null => {\n\tconst {cells, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\t//if (currentPlayer !== AIPlayer) return null;\n\n\tconst cellsCopy = [...cells];\n\tconst boardDataCopy = {\n\t\t...boardData,\n\t\tcells: cellsCopy,\n\t};\n\n\tlet bestValue = isMaximizer(currentPlayer) ? -100 : 100;\n\tlet bestMove = -1;\n\n\tboardDataCopy.cells.forEach((cell, index) => {\n\t\tif (cell.takenByPlayer === '') {\n\t\t\tcell.takenByPlayer = currentPlayer;\n\n\t\t\tconst newBoardData = {\n\t\t\t\t...boardDataCopy,\n\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\tlastCellIndex: index,\n\t\t\t}\n\n\t\t\tlet moveValue = minimax(0, newBoardData);\n\n\t\t\tcell.takenByPlayer = '';\n\n\t\t\tif (isMaximizer(currentPlayer) && moveValue > bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\n\t\t\tif (!isMaximizer(currentPlayer) && moveValue < bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn bestMove;\n}"]},"metadata":{},"sourceType":"module"}