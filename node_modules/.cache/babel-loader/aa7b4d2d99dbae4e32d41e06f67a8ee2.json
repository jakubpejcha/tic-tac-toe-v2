{"ast":null,"code":"import { checkWinner } from './checkWinner';\n\nconst evaluateBoard = (result, isMaximizer) => {\n  if (!result) {\n    return 0;\n  } else if (isMaximizer) {\n    return 10;\n  } else {\n    return -10;\n  }\n};\n\nconst isMovesLeft = cells => {\n  for (const cell of cells) {\n    if (cell.takenByPlayer === '') return true;\n  }\n\n  return false;\n};\n\nconst swapPlayers = currentPlayer => {\n  if (currentPlayer === 'x') return 'o';\n  return 'x';\n};\n\n// cells will be a copy\nconst minimax = (depth, boardData, isMaximizer) => {\n  const {\n    cells: cellsCopy,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData;\n  const result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n  const boardScore = evaluateBoard(result, isMaximizer);\n  console.log(boardScore);\n  if (boardScore === 10) return boardScore;\n  if (boardScore === -10) return boardScore;\n  if (!isMovesLeft(cellsCopy)) return 0; // do not modify cells\n  //const cellsCopy = [...cells];\n\n  let best = -100;\n\n  if (isMaximizer) {\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = swapPlayers(currentPlayer);\n        console.log(cellsCopy[index].takenByPlayer);\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n        cell.takenByPlayer = '';\n      }\n    });\n  } else {\n    best = 100;\n    cellsCopy.forEach((cell, index) => {\n      if (cell.takenByPlayer === '') {\n        cell.takenByPlayer = swapPlayers(currentPlayer);\n        const newBoardData = { ...boardData,\n          cells: cellsCopy,\n          currentPlayer: swapPlayers(currentPlayer),\n          lastCellIndex: index\n        };\n        best = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n        cell.takenByPlayer = '';\n      }\n    });\n  }\n\n  return best;\n};\n\nexport const findBestMove = boardData => {\n  const {\n    cells,\n    currentPlayer,\n    size,\n    lastCellIndex,\n    winStreak\n  } = boardData;\n  const cellsCopy = [...cells];\n  const boardDataCopy = { ...boardData,\n    cells: cellsCopy\n  };\n  let bestValue = -100;\n  let bestMove = -1;\n  boardDataCopy.cells.forEach((cell, index) => {\n    if (cell.takenByPlayer === '') {\n      cell.takenByPlayer = currentPlayer;\n      boardDataCopy.lastCellIndex = index; // const newBoardData = {\n      // \t...boardDataCopy,\n      // \tlastCellIndex: index,\n      // }\n      //console.log(boardDataCopy);\n\n      let moveValue = minimax(0, boardDataCopy, true); //console.log(moveValue);\n\n      cell.takenByPlayer = '';\n\n      if (moveValue > bestValue) {\n        bestValue = moveValue;\n        bestMove = index;\n      }\n    }\n  });\n  return bestMove;\n};","map":{"version":3,"sources":["/home/jakub/Projects/tic-tac-toe/src/minimax.ts"],"names":["checkWinner","evaluateBoard","result","isMaximizer","isMovesLeft","cells","cell","takenByPlayer","swapPlayers","currentPlayer","minimax","depth","boardData","cellsCopy","size","lastCellIndex","winStreak","boardScore","console","log","best","forEach","index","newBoardData","Math","max","min","findBestMove","boardDataCopy","bestValue","bestMove","moveValue"],"mappings":"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","sourcesContent":["import { checkWinner } from './checkWinner';\nimport { CellInterface } from './shared/interfaces';\n\nconst evaluateBoard = (result: boolean | number[], isMaximizer: boolean): number => {\n\n\tif (!result) {\n\t\treturn 0;\n\t} else if (isMaximizer) {\n\t\treturn 10;\n\t} else {\n\t\treturn -10;\n\t}\n}\n\nconst isMovesLeft = (cells: CellInterface[]) => {\n\tfor (const cell of cells) {\n\t\tif (cell.takenByPlayer === '') return true;\n\t}\n\treturn false;\n}\n\nconst swapPlayers = (currentPlayer: string) => {\n\tif (currentPlayer === 'x') return 'o';\n\treturn 'x';\n}\n\ninterface BoardData {\n\tcells: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tlastCellIndex: number,\n\twinStreak: number\n}\n\n// cells will be a copy\nconst minimax = (depth: number, boardData: BoardData, isMaximizer: boolean): number => {\n\tconst {cells: cellsCopy, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n\tconst boardScore = evaluateBoard(result, isMaximizer);\n\tconsole.log(boardScore);\n\t\n\n\tif (boardScore === 10) return boardScore;\n\tif (boardScore === -10) return boardScore;\n\tif (!isMovesLeft(cellsCopy)) return 0;\n\n\t// do not modify cells\n\t//const cellsCopy = [...cells];\n\tlet best = -100;\n\n\tif (isMaximizer) {\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\t\t\t\tconsole.log(cellsCopy[index].takenByPlayer);\n\t\t\t\t\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\n\t} else {\n\t\tbest = 100;\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\t}\n\n\treturn best;\n}\n\nexport const findBestMove = (boardData: BoardData):number => {\n\tconst {cells, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst cellsCopy = [...cells];\n\tconst boardDataCopy = {\n\t\t...boardData,\n\t\tcells: cellsCopy,\n\t};\n\n\tlet bestValue = -100;\n\tlet bestMove = -1;\n\t\n\tboardDataCopy.cells.forEach((cell, index) => {\n\t\tif (cell.takenByPlayer === '') {\n\t\t\tcell.takenByPlayer = currentPlayer;\n\t\t\tboardDataCopy.lastCellIndex = index;\n\t\t\t// const newBoardData = {\n\t\t\t// \t...boardDataCopy,\n\t\t\t// \tlastCellIndex: index,\n\t\t\t// }\n\t\t\t//console.log(boardDataCopy);\n\t\t\t\n\n\t\t\tlet moveValue = minimax(0, boardDataCopy, true);\n\t\t\t//console.log(moveValue);\n\t\t\t\n\n\t\t\tcell.takenByPlayer = '';\n\n\t\t\tif (moveValue > bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn bestMove;\n}"]},"metadata":{},"sourceType":"module"}