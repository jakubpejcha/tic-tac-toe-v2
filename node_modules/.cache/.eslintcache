[{"/home/jakub/Projects/tic-tac-toe/src/index.tsx":"1","/home/jakub/Projects/tic-tac-toe/src/App.tsx":"2","/home/jakub/Projects/tic-tac-toe/src/Game.tsx":"3","/home/jakub/Projects/tic-tac-toe/src/Welcome.tsx":"4","/home/jakub/Projects/tic-tac-toe/src/Board.tsx":"5","/home/jakub/Projects/tic-tac-toe/src/ThemeToggler.tsx":"6","/home/jakub/Projects/tic-tac-toe/src/Restart.tsx":"7","/home/jakub/Projects/tic-tac-toe/src/Score.tsx":"8","/home/jakub/Projects/tic-tac-toe/src/Back.tsx":"9","/home/jakub/Projects/tic-tac-toe/src/GameMenu.tsx":"10","/home/jakub/Projects/tic-tac-toe/src/checkWinner.ts":"11","/home/jakub/Projects/tic-tac-toe/src/minimax.ts":"12","/home/jakub/Projects/tic-tac-toe/src/Cell.tsx":"13","/home/jakub/Projects/tic-tac-toe/src/Modal.tsx":"14"},{"size":198,"mtime":1625752069374,"results":"15","hashOfConfig":"16"},{"size":469,"mtime":1626091724620,"results":"17","hashOfConfig":"16"},{"size":1637,"mtime":1626179348490,"results":"18","hashOfConfig":"16"},{"size":1226,"mtime":1626179413274,"results":"19","hashOfConfig":"16"},{"size":4734,"mtime":1626091724620,"results":"20","hashOfConfig":"16"},{"size":354,"mtime":1626091724620,"results":"21","hashOfConfig":"16"},{"size":338,"mtime":1626091724620,"results":"22","hashOfConfig":"16"},{"size":731,"mtime":1626091724620,"results":"23","hashOfConfig":"16"},{"size":686,"mtime":1626179389638,"results":"24","hashOfConfig":"16"},{"size":216,"mtime":1626091724620,"results":"25","hashOfConfig":"16"},{"size":4092,"mtime":1626091724620,"results":"26","hashOfConfig":"16"},{"size":2855,"mtime":1626091724620,"results":"27","hashOfConfig":"16"},{"size":1063,"mtime":1625161714995,"results":"28","hashOfConfig":"16"},{"size":896,"mtime":1626091724620,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1o1ofki",{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/jakub/Projects/tic-tac-toe/src/index.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/App.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Game.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Welcome.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Board.tsx",["60","61","62","63"],"import { useState, useEffect } from 'react';\nimport Cell from './Cell';\nimport { CellInterface } from './shared/interfaces';\nimport { checkWinner } from './checkWinner';\nimport { findBestMove } from './minimax';\nimport Modal from './Modal';\nimport './styles/Board.css';\n\ninterface Dimensions {\n\tBOARD_NUM_ROWS: number,\n\tSIZE: string,\n\tDELAY: number,\n\tWIN_STREAK: number\n}\n\nconst getDimensions = (numRows: number): Dimensions => {\n\tconst dimensions = {\n\t\tBOARD_NUM_ROWS: numRows,\n\t\tSIZE: '',\n\t\tDELAY: 0,\n\t\tWIN_STREAK: 0\n\t}\n\n\tif (numRows === 3) dimensions.SIZE = '--small';\n\tif (numRows === 10) dimensions.SIZE = '--large';\n\n\tif (numRows === 3) dimensions.DELAY = 150;\n\tif (numRows === 10) dimensions.DELAY = 10;\n\n\tdimensions.WIN_STREAK = numRows >= 5 ? 5 : numRows;\n\n\treturn dimensions;\n}\n\ninterface Props {\n\tscoreHandler: (updatePlayer: string) => void,\n\trestart: boolean,\n\thandleRestart: (restart: boolean) => void,\n\tsize: number,\n\tisAI:boolean\n}\n\nconst Board = ({ scoreHandler, restart, handleRestart, size, isAI }: Props) => {\n\n\tconst dimensions = getDimensions(size);\n\n\tconst [isWinner, setIsWinner] = useState(false);\n\n\tconst [isDraw, setIsDraw] = useState(false);\n\n\tconst [numMoves, setNumMoves] = useState(0);\n\n\tconst [player, setPlayer] = useState('x');\n\n\tconst [cells, setCells] = useState<CellInterface[]>(Array(dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS).fill({\n\t\tshowClassName: '',\n\t\ttakenByPlayer: '',\n\t\twinning: false,\n\t}));\n\n\tconst [lastCell, setLastCell] = useState(-1);\n\n\t// restart board\n\tuseEffect(() => {\n\t\t\n\t\tif (!restart) return;\n\n\t\tsetIsWinner(false);\n\t\tsetIsDraw(false);\n\t\tsetNumMoves(0);\n\t\tsetPlayer('x');\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetCells(prevCells => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\tnewCells[index] = {\n\t\t\t\t\t...cell,\n\t\t\t\t\ttakenByPlayer: '',\n\t\t\t\t\twinning: false\n\t\t\t\t}\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t});\n\t\t\n\t\tsetLastCell(-1);\n\n\t\thandleRestart(false);\n\t\t\n\t}, [restart]);\n\n\t// Nice animation of creating the board\n\tconst showBoard = () => {\n\n\t\tcells.forEach((cell, index) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetCells((prevCells) => {\n\t\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\t\tnewCells[index] = {\n\t\t\t\t\t\t...cell,\n\t\t\t\t\t\tshowClassName: ' show'\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn newCells;\n\t\t\t\t});\n\t\t\t}, index * dimensions.DELAY);\n\t\t});\n\t};\n\n\tuseEffect(() => {\n\t\tshowBoard();\n\t}, []);\n\n\tconst onCellClick = (index: number) => {\n\t\tsetCells((prevCells => {\n\t\t\t// in case cell has been clicked before\n\t\t\tif (prevCells[index].takenByPlayer !== '' || isWinner) return prevCells;\n\n\t\t\tconst newCells = [...prevCells];\n\n\t\t\tnewCells[index] = {\n\t\t\t\t...prevCells[index],\n\t\t\t\ttakenByPlayer: ` ${player}`\n\t\t\t}\n\n\t\t\tsetNumMoves(prevNum => prevNum + 1);\n\t\t\tsetLastCell(index);\n\n\t\t\treturn newCells;\n\t\t}));\n\n\t};\n\n\tuseEffect(() => {\n\t\t//TEST\n\t\tif (lastCell === -1) return; // do not run after app starts\n\n\t\tconst result: boolean | number[] = checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK);\n\t\t\n\t\tif (result && Array.isArray(result)) {\n\t\t\tsetIsWinner(true);\n\t\t\tscoreHandler(player);\n\t\t\tsetCells((prevCells) => {\n\t\t\t\tconst newCells = [...prevCells];\n\t\t\t\tresult.forEach(cell => {\n\t\t\t\t\tnewCells[cell] = {\n\t\t\t\t\t\t...prevCells[cell],\n\t\t\t\t\t\twinning: true,\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\treturn newCells;\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\t//console.log(checkWinner(cells, player, dimensions.BOARD_NUM_ROWS, lastCell, dimensions.WIN_STREAK));\n\t\t\n\n\t\t// check for draw\n\t\tif (numMoves === dimensions.BOARD_NUM_ROWS * dimensions.BOARD_NUM_ROWS) {\n\t\t\tsetIsDraw(true);\n\t\t\treturn;\n\t\t};\n\n\t\tsetPlayer((prevPlayer) => {\n\t\t\tif (prevPlayer === 'x') return 'o';\n\t\t\treturn 'x';\n\t\t});\n\n\t}, [lastCell]);\n\n\t//AI move\n\tuseEffect(() => {\n\t\tif (player === 'o' && isAI) {\n\n\t\t\tsetCells((prevCells => {\n\t\t\t\t// in case cell has been clicked before\n\t\t\t\t// forAI\n\t\t\t\tconst boardData = {\n\t\t\t\t\tcells: prevCells,\n\t\t\t\t\tcurrentPlayer: 'o',\n\t\t\t\t\tsize: dimensions.BOARD_NUM_ROWS,\n\t\t\t\t\tlastCellIndex: lastCell,\n\t\t\t\t\twinStreak: dimensions.WIN_STREAK\n\t\t\t\t}\n\n\t\t\t\tconst index = findBestMove(boardData);\n\t\n\t\t\t\tconst newCells = [...prevCells];\n\t\n\t\t\t\tnewCells[index] = {\n\t\t\t\t\t...prevCells[index],\n\t\t\t\t\ttakenByPlayer: ' o'\n\t\t\t\t}\n\n\t\t\t\tsetNumMoves(prevNum => prevNum + 1);\n\t\t\t\tsetLastCell(index);\n\t\n\t\t\t\treturn newCells;\n\t\t\t}));\n\t\t}\n\t}, [player]);\n\n\treturn (\n\t\t<>\n\t\t\t<div className={`board board_${dimensions.BOARD_NUM_ROWS}`}>\n\t\t\t\t{cells.map((cell, pos) => (\n\t\t\t\t\t<Cell\n\t\t\t\t\t\tkey={pos}\n\t\t\t\t\t\tindex={pos}\n\t\t\t\t\t\tshowClassName={cell.showClassName}\n\t\t\t\t\t\ttakenByPlayer={cell.takenByPlayer}\n\t\t\t\t\t\twinning={cell.winning}\n\t\t\t\t\t\tcurrentPlayer={` current_${player}`}\n\t\t\t\t\t\tsize={dimensions.SIZE}\n\t\t\t\t\t\tonClickCallback={onCellClick}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t\t<Modal isWinner={isWinner} isDraw={isDraw} winner={player} />\n\t\t</>\n\t)\n};\n\nexport default Board;","/home/jakub/Projects/tic-tac-toe/src/ThemeToggler.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Restart.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Score.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Back.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/GameMenu.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/checkWinner.ts",[],"/home/jakub/Projects/tic-tac-toe/src/minimax.ts",["64","65","66"],"import { checkWinner } from './checkWinner';\nimport { CellInterface } from './shared/interfaces';\n\nconst evaluateBoard = (result: boolean | number[], isMaximizer: boolean): number => {\n\n\tif (!result) {\n\t\treturn 0;\n\t} else if (isMaximizer) {\n\t\treturn 10;\n\t} else {\n\t\treturn -10;\n\t}\n}\n\nconst isMovesLeft = (cells: CellInterface[]) => {\n\tfor (const cell of cells) {\n\t\tif (cell.takenByPlayer === '') return true;\n\t}\n\treturn false;\n}\n\nconst swapPlayers = (currentPlayer: string) => {\n\tif (currentPlayer === 'x') return 'o';\n\treturn 'x';\n}\n\ninterface BoardData {\n\tcells: CellInterface[],\n\tcurrentPlayer: string,\n\tsize: number,\n\tlastCellIndex: number,\n\twinStreak: number\n}\n\n// cells will be a copy\nconst minimax = (depth: number, boardData: BoardData, isMaximizer: boolean): number => {\n\tconst {cells: cellsCopy, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst result = checkWinner(cellsCopy, currentPlayer, size, lastCellIndex, winStreak);\n\tconst boardScore = evaluateBoard(result, isMaximizer);\n\t\n\n\tif (boardScore === 10) return boardScore;\n\tif (boardScore === -10) return boardScore;\n\tif (!isMovesLeft(cellsCopy)) return 0;\n\n\t// do not modify cells\n\tlet best = -100;\n\n\tif (isMaximizer) {\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\t\t\t\t//console.log(cellsCopy[index].takenByPlayer);\n\t\t\t\t\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.max(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\n\t} else {\n\t\tbest = 100;\n\n\t\tcellsCopy.forEach((cell, index) => {\n\t\t\tif (cell.takenByPlayer === '') {\n\t\t\t\tcell.takenByPlayer = swapPlayers(currentPlayer);\n\n\t\t\t\tconst newBoardData: BoardData = {\n\t\t\t\t\t...boardData,\n\t\t\t\t\tcells: cellsCopy,\n\t\t\t\t\tcurrentPlayer: swapPlayers(currentPlayer),\n\t\t\t\t\tlastCellIndex: index,\n\t\t\t\t}\n\t\t\t\tbest = Math.min(best, minimax(depth + 1, newBoardData, !isMaximizer));\n\n\t\t\t\tcell.takenByPlayer = '';\n\t\t\t}\n\t\t});\n\t}\n\n\treturn best;\n}\n\nexport const findBestMove = (boardData: BoardData):number => {\n\tconst {cells, currentPlayer, size, lastCellIndex, winStreak} = boardData;\n\n\tconst cellsCopy = [...cells];\n\tconst boardDataCopy = {\n\t\t...boardData,\n\t\tcells: cellsCopy,\n\t};\n\tconsole.log('called finder');\n\t\n\tlet bestValue = -100;\n\tlet bestMove = -1;\n\t\n\tboardDataCopy.cells.forEach((cell, index) => {\t\n\t\tif (cell.takenByPlayer === '') {\n\t\t\tcell.takenByPlayer = currentPlayer;\n\t\t\tboardDataCopy.lastCellIndex = index;\n\n\t\t\tconsole.time('minimax')\n\t\t\tlet moveValue = minimax(0, boardDataCopy, true);\n\t\t\tconsole.timeEnd('minimax')\n\t\t\t\n\n\t\t\tcell.takenByPlayer = '';\n\n\t\t\tif (moveValue > bestValue) {\n\t\t\t\tbestValue = moveValue;\n\t\t\t\tbestMove = index;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn bestMove;\n}","/home/jakub/Projects/tic-tac-toe/src/Cell.tsx",[],"/home/jakub/Projects/tic-tac-toe/src/Modal.tsx",[],{"ruleId":"67","severity":1,"message":"68","line":91,"column":5,"nodeType":"69","endLine":91,"endColumn":14,"suggestions":"70"},{"ruleId":"67","severity":1,"message":"71","line":114,"column":5,"nodeType":"69","endLine":114,"endColumn":7,"suggestions":"72"},{"ruleId":"67","severity":1,"message":"73","line":172,"column":5,"nodeType":"69","endLine":172,"endColumn":15,"suggestions":"74"},{"ruleId":"67","severity":1,"message":"75","line":204,"column":5,"nodeType":"69","endLine":204,"endColumn":13,"suggestions":"76"},{"ruleId":"77","severity":1,"message":"78","line":94,"column":31,"nodeType":"79","messageId":"80","endLine":94,"endColumn":35},{"ruleId":"77","severity":1,"message":"81","line":94,"column":37,"nodeType":"79","messageId":"80","endLine":94,"endColumn":50},{"ruleId":"77","severity":1,"message":"82","line":94,"column":52,"nodeType":"79","messageId":"80","endLine":94,"endColumn":61},"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'cells' and 'handleRestart'. Either include them or remove the dependency array. If 'handleRestart' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["83"],"React Hook useEffect has a missing dependency: 'showBoard'. Either include it or remove the dependency array.",["84"],"React Hook useEffect has missing dependencies: 'cells', 'dimensions.BOARD_NUM_ROWS', 'dimensions.WIN_STREAK', 'numMoves', 'player', and 'scoreHandler'. Either include them or remove the dependency array. If 'scoreHandler' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["85"],"React Hook useEffect has missing dependencies: 'dimensions.BOARD_NUM_ROWS', 'dimensions.WIN_STREAK', 'isAI', and 'lastCell'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setCells' needs the current value of 'lastCell'.",["86"],"@typescript-eslint/no-unused-vars","'size' is assigned a value but never used.","Identifier","unusedVar","'lastCellIndex' is assigned a value but never used.","'winStreak' is assigned a value but never used.",{"desc":"87","fix":"88"},{"desc":"89","fix":"90"},{"desc":"91","fix":"92"},{"desc":"93","fix":"94"},"Update the dependencies array to be: [cells, handleRestart, restart]",{"range":"95","text":"96"},"Update the dependencies array to be: [showBoard]",{"range":"97","text":"98"},"Update the dependencies array to be: [cells, dimensions.BOARD_NUM_ROWS, dimensions.WIN_STREAK, lastCell, numMoves, player, scoreHandler]",{"range":"99","text":"100"},"Update the dependencies array to be: [dimensions.BOARD_NUM_ROWS, dimensions.WIN_STREAK, isAI, lastCell, player]",{"range":"101","text":"102"},[1921,1930],"[cells, handleRestart, restart]",[2320,2322],"[showBoard]",[3605,3615],"[cells, dimensions.BOARD_NUM_ROWS, dimensions.WIN_STREAK, lastCell, numMoves, player, scoreHandler]",[4222,4230],"[dimensions.BOARD_NUM_ROWS, dimensions.WIN_STREAK, isAI, lastCell, player]"]